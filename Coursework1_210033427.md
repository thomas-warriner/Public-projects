MTH6139 Time Series
================
Thomas Warriner
Spring term 2025

<img src="data:image/png;base64,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" alt="logo" style="position:absolute; top:0; right:0; padding:10px; width:20%;"/>

# An introduction to the project

My aim for this brief project is to present a data-modelling journey,
through both pre-known methods in `R` and with a new tool, Meta’s
‘Prophet’.

I aim to garner some insights into the package’s inbuilt `co2` dataset,
and then explore a dataset of my own discovery.

# Meta’s Prophet

## The co2 dataset

Using R we can pull out some basic information from the co2 dataset
inbuilt to `R`. **Note this is not to be confused with the CO2 dataset
inbuilt to R which not a time series**

``` r
data(co2)
```

``` r
head(co2) ##View the start of the data
```

    ## [1] 315.42 316.31 316.50 317.56 318.13 318.00

``` r
tail(co2)  ##View the end of the data
```

    ## [1] 364.52 362.57 360.24 360.83 362.49 364.34

``` r
summary(co2)  ##View key statistics
```

    ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    ##   313.2   323.5   335.2   337.1   350.3   366.8

``` r
plot(co2,
     main = "Atmospheric CO2 at
     the Mauna Loa observatory",
     xlab = "Year", ylab = "CO2 (pp million)")
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-4-1.png)<!-- -->

We can immediately see an increasing trend, broadly linear but possibly
polynomial and perhaps exponential. But what are we actually looking at?

The R documentation for the dataset reveals that this data shows the
concentration of CO2 in the air as parts per million as measured between
1959 and 1997 at the Mauna Loa Observatory in Hawai’i.

Intuitively, the yearly trend could be explained by the carbon cycle in
plants, with plants photosynthesising in the Summer, reducing CO2. And
the overall trend fits with our modern-day understanding of the role
human habits are playing in polluting the atmosphere with greenhouse
gases, contributing to global warming.

Let us use apply regression to get a greater understanding of the trend.

## Simple analysis

``` r
co2.df = data.frame(
  ds=as.yearmon(time(co2)), 
  y=co2)
```

A good first step would be a simple linear regression model

``` r
linear_model = lm(y~ds, data = co2.df)
linear_model$coefficients
```

    ##  (Intercept)           ds 
    ## -2249.774198     1.307497

``` r
summary(linear_model)
```

    ## 
    ## Call:
    ## lm(formula = y ~ ds, data = co2.df)
    ## 
    ## Residuals:
    ##     Min      1Q  Median      3Q     Max 
    ## -6.0399 -1.9476 -0.0017  1.9113  6.5149 
    ## 
    ## Coefficients:
    ##               Estimate Std. Error t value
    ## (Intercept) -2.250e+03  2.127e+01  -105.8
    ## ds           1.308e+00  1.075e-02   121.6
    ##             Pr(>|t|)    
    ## (Intercept)   <2e-16 ***
    ## ds            <2e-16 ***
    ## ---
    ## Signif. codes:  
    ## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ## 
    ## Residual standard error: 2.618 on 466 degrees of freedom
    ## Multiple R-squared:  0.9695, Adjusted R-squared:  0.9694 
    ## F-statistic: 1.479e+04 on 1 and 466 DF,  p-value: < 2.2e-16

The same graph as above, with this model indicated:

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-7-1.png)<!-- -->

We could also fit a quadratic and exponential models:

``` r
quad_model = lm(y~ds+I(ds^2), data = co2.df)
quad_model$coefficients
```

    ##   (Intercept)            ds       I(ds^2) 
    ##  4.770455e+04 -4.919237e+01  1.276243e-02

``` r
summary(quad_model)
```

    ## 
    ## Call:
    ## lm(formula = y ~ ds + I(ds^2), data = co2.df)
    ## 
    ## Residuals:
    ##     Min      1Q  Median      3Q     Max 
    ## -5.0195 -1.7120  0.2142  1.7960  4.8346 
    ## 
    ## Coefficients:
    ##               Estimate Std. Error t value
    ## (Intercept)  4.770e+04  3.483e+03   13.70
    ## ds          -4.919e+01  3.521e+00  -13.97
    ## I(ds^2)      1.276e-02  8.898e-04   14.34
    ##             Pr(>|t|)    
    ## (Intercept)   <2e-16 ***
    ## ds            <2e-16 ***
    ## I(ds^2)       <2e-16 ***
    ## ---
    ## Signif. codes:  
    ## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ## 
    ## Residual standard error: 2.182 on 465 degrees of freedom
    ## Multiple R-squared:  0.9788, Adjusted R-squared:  0.9787 
    ## F-statistic: 1.075e+04 on 2 and 465 DF,  p-value: < 2.2e-16

``` r
exp_model = lm(log(y)~ds, data = co2.df)
exp_model$coefficients
```

    ##  (Intercept)           ds 
    ## -1.835404298  0.003869006

``` r
summary(exp_model)
```

    ## 
    ## Call:
    ## lm(formula = log(y) ~ ds, data = co2.df)
    ## 
    ## Residuals:
    ##        Min         1Q     Median         3Q 
    ## -0.0172650 -0.0056145  0.0002764  0.0053760 
    ##        Max 
    ##  0.0187770 
    ## 
    ## Coefficients:
    ##               Estimate Std. Error t value
    ## (Intercept) -1.835e+00  5.991e-02  -30.64
    ## ds           3.869e-03  3.028e-05  127.77
    ##             Pr(>|t|)    
    ## (Intercept)   <2e-16 ***
    ## ds            <2e-16 ***
    ## ---
    ## Signif. codes:  
    ## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ## 
    ## Residual standard error: 0.007375 on 466 degrees of freedom
    ## Multiple R-squared:  0.9722, Adjusted R-squared:  0.9722 
    ## F-statistic: 1.633e+04 on 1 and 466 DF,  p-value: < 2.2e-16

``` r
par(mfrow = c(1,3))

plot(co2,
     main = "Linear",
     xlab = "Year", ylab = "CO2")
points(co2.df$ds, fitted.values(linear_model),
       type = "l", col = "tomato")

plot(co2,
     main = "Quadratic",
     xlab = "Year", ylab = "CO2")
points(co2.df$ds, fitted.values(quad_model),
       type = "l", col = "turquoise")

plot(co2,
     main = "Exponential",
     xlab = "Year", ylab = "CO2")
points(co2.df$ds, exp(fitted.values(exp_model)),
       type = "l", col = "gold")
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-8-1.png)<!-- -->

We could predict the CO2 levels of CO2 in February 2025 using the
quadratic model.

``` r
c = quad_model$coefficients[1]
b = quad_model$coefficients[2]
a = quad_model$coefficients[3]

Month_now = zoo::as.yearmon("Feb 2025")
x = as.double(Month_now)
```

Simply substitute in the values as per a quadratic equation
$ax^2 + bx + c$

``` r
Feb_prediction = a*x^2 + b*x + c
Feb_prediction
```

    ##  I(ds^2) 
    ## 424.1423

Comparing this to [the actual figure](https://gml.noaa.gov/ccgg/trends/)
of 427.09 yields a shockingly accurate conclusion.

<img src="images/MaunaLoa_Febactual.png" width="356" />

The error is a tiny 0.69%!

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-11-1.png)<!-- -->

## Prophet analysis

### Motivation

The aim of this project was not to show that Meta’s prophet is weak in
comparison to a quadratic regression model - this definitely is not the
case - but the bar is certainly high!

If we decompose the time series, we can clearly see a yearly seasonality
which is not captured by our quadratic model.

``` r
plot(decompose(co2), cex.lab = 0.55)
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-12-1.png)<!-- -->

Perform a Breusch-Pagan test to check for heteroscedasticity.

``` r
lmtest::bptest(co2.df$y~co2.df$ds)
```

    ## 
    ##  studentized Breusch-Pagan test
    ## 
    ## data:  co2.df$y ~ co2.df$ds
    ## BP = 3.6238, df = 1, p-value = 0.05696

At the 5% significance level we would keep the hypothesis that the error
is homoscedastic, but this is borderline and could be studied
further.<sup>E1</sup>

### Prophet

The quadratic model seems effective, but is limited to predicting a
value which ignores the month’s place in the year. Let us explore the
options Prophet has for us. I will leave inputs as default for now.

``` r
model_prophet = prophet(co2.df)
future_prophet = make_future_dataframe(model_prophet,
                                       30*12,
                                       freq = "month")
predict_prophet = predict(model_prophet,
                          future_prophet)
plot(model_prophet,predict_prophet)
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-14-1.png)<!-- -->

This has produced a model which we can visualise, capturing the yearly
trend, and also giving an interval showing decreasing confidence in the
model over time.

To play around with fine tuning Prophet, I’ll define a function for
brevity which collects the above lines in one.

``` r
prophet_process = function(model){
    myfuture = make_future_dataframe(model,
                                     30*12,
                                     freq = "month")
    mypredict = predict(model, myfuture)
    plot(model,mypredict)
}
```

Let us see what the model looks like if we forget about yearly trend.

``` r
prophet_process(prophet(co2.df, yearly.seasonality = FALSE))
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-16-1.png)<!-- -->

Note not only that not only is the model now predicting without the
‘wavy’ yearly trend, but its confidence in the predictions has
increased, with the cone around the predictions narrowing. I have
laboured to explain this, but have not been able to figure this out. My
instinct would have been that the same degree of uncertainty is left
over after taking away yearly trend from the ‘wavy’ model: a point for
further study later.<sup>Q1</sup>

We could allow Prophet to reduce its certainty from the default value of
0.8 down to 0.5.

``` r
prophet_process(prophet(co2.df, yearly.seasonality = TRUE, interval.width = 0.5))
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-17-1.png)<!-- -->

We could even choose to make estimates via Monte Carlo methods rather
than taking precise calculations. This processes much quicker on my
computer, but the lower parameters are clearly inaccurate based on our
knowledge of the yearly seasonal pattern. 100 however is
indistinguishable from the exact case.

``` r
set.seed(0)
par(mfrow = c(1,3))
prophet_process(prophet(co2.df, mcmc.samples = 10))
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-18-1.png)<!-- -->

``` r
prophet_process(prophet(co2.df, mcmc.samples = 20))
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-18-2.png)<!-- -->

``` r
prophet_process(prophet(co2.df, mcmc.samples = 100))
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-18-3.png)<!-- -->

The question on your mind, I’m sure, is whether Prophet predicted
February 2025 better or worse than the simple quadratic model.

Reminder: the quadratic model predicted 424.1423 pp million. The actual
figure was 427.09 pp million, giving a 0.69% error.

Let’s see what Prophet predicts.

``` r
prophet_Feb2025 = predict_prophet[predict_prophet$ds == "2025-02-01",]$yhat
prophet_Feb2025
```

    ## [1] 403.3018

``` r
(427.09-prophet_Feb2025)/427.09
```

    ## [1] 0.05569826

Prophet yields a 5.58% error!

The key here is that despite compensating for seasonality, the prophet
forecaster only offers the options for `trend` of linear, logistic, and
flat, not quadratic. We will add ‘*how to create a quadratic model in
prophet*’ to things to study at a later date.<sup>Q2</sup>

## Best of both worlds

Let us attempt to build a quadratic model taking into account yearly
seasonality ourselves.

``` r
MaunaLoa_months = co2.df$ds - trunc(as.double(co2.df$ds))
month_labels = format(as.Date(co2.df$ds), "%B")
head(month_labels)
```

    ## [1] "January"  "February" "March"    "April"   
    ## [5] "May"      "June"

``` r
combined_model = lcombined_model = lcombined_model = lm(y~ds+I(ds^2)+month_labels, data = co2.df)

plot(co2,
     main = "Combined model",
     xlab = "Year", ylab = "CO2")
points(co2.df$ds, fitted.values(combined_model),
       type = "l", col = "pink")
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-20-1.png)<!-- -->

What a great fit! Let’s use it to predict.

``` r
summary(combined_model)
```

    ## 
    ## Call:
    ## lm(formula = y ~ ds + I(ds^2) + month_labels, data = co2.df)
    ## 
    ## Residuals:
    ##      Min       1Q   Median       3Q      Max 
    ## -1.99478 -0.54468 -0.06017  0.47265  1.95480 
    ## 
    ## Coefficients:
    ##                         Estimate Std. Error
    ## (Intercept)            4.771e+04  1.156e+03
    ## ds                    -4.920e+01  1.168e+00
    ## I(ds^2)                1.277e-02  2.952e-04
    ## month_labelsAugust    -3.774e+00  1.640e-01
    ## month_labelsDecember  -3.476e+00  1.640e-01
    ## month_labelsFebruary  -1.875e+00  1.640e-01
    ## month_labelsJanuary   -2.539e+00  1.640e-01
    ## month_labelsJuly      -1.706e+00  1.640e-01
    ## month_labelsJune      -1.847e-01  1.640e-01
    ## month_labelsMarch     -1.132e+00  1.640e-01
    ## month_labelsMay        4.784e-01  1.640e-01
    ## month_labelsNovember  -4.593e+00  1.640e-01
    ## month_labelsOctober   -5.781e+00  1.640e-01
    ## month_labelsSeptember -5.598e+00  1.640e-01
    ##                       t value Pr(>|t|)    
    ## (Intercept)            41.291  < 2e-16 ***
    ## ds                    -42.120  < 2e-16 ***
    ## I(ds^2)                43.242  < 2e-16 ***
    ## month_labelsAugust    -23.015  < 2e-16 ***
    ## month_labelsDecember  -21.201  < 2e-16 ***
    ## month_labelsFebruary  -11.433  < 2e-16 ***
    ## month_labelsJanuary   -15.485  < 2e-16 ***
    ## month_labelsJuly      -10.404  < 2e-16 ***
    ## month_labelsJune       -1.127   0.2604    
    ## month_labelsMarch      -6.901 1.74e-11 ***
    ## month_labelsMay         2.918   0.0037 ** 
    ## month_labelsNovember  -28.009  < 2e-16 ***
    ## month_labelsOctober   -35.257  < 2e-16 ***
    ## month_labelsSeptember -34.142  < 2e-16 ***
    ## ---
    ## Signif. codes:  
    ## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ## 
    ## Residual standard error: 0.724 on 454 degrees of freedom
    ## Multiple R-squared:  0.9977, Adjusted R-squared:  0.9977 
    ## F-statistic: 1.531e+04 on 13 and 454 DF,  p-value: < 2.2e-16

So to predict the CO2 levels we would form the equation $ax^2+bx+c+d$
where d is the added constant for February, -1.875. I would already
invalidate this model. As discussed earlier, we expect more CO2 in the
atmosphere in the Winter, not less.

``` r
d = combined_model$coefficients["month_labelsFebruary"]

new_Feb_prediction = a*x^2 + b*x + c + d
new_Feb_prediction
```

    ##  I(ds^2) 
    ## 422.2678

``` r
(427.09-new_Feb_prediction)/427.09
```

    ##    I(ds^2) 
    ## 0.01129088

Indeed, we are now 1.13% inaccurate.

## Takeaways

From this exercise I have refined my understanding of linear regression
in `R` and been introduced to the Prophet forecasting tool. The analysis
here presented is helpful both as a guide to such modelling methods in
`R` and, perhaps as a proof that the simplest solutions are sometimes
the best.

# Santander Bikes

## Motivation

In-keeping with the climate-conscious theme, I will use prophet to look
at the lengths of journeys taken by people on Santander bikes. If you
are unfamiliar with the scheme, around London there are a number of
docking stations into which large, red bicycles can be affixed, see
image below. It is important to note that each station has a unique
name.

At a reasonable rate, Londoners can hire the bikes (affectionately known
as Boris Bikes for the London mayor at the time of introduction) for
commuting, leisure, or exercise. I personally have used them for all 3
of these purposes, and find the scheme to be excellent.

![](images/Santander_bikes.jpg)

## The data

TFL releases free data of all journeys taken on the bikes, including the
start and end times, and the start and end docking stations. Yes,
really! Every individual journey is logged and available to view. The
below is a journey I may very well have taken to get to work in April,
from the East end suburbs (Furze Green) to an urban district in the city
(Finsbury Square).

``` r
bikes_example = read.csv("data/Bikes/393JourneyDataExtract01Apr2024-14Apr2024.csv")
bikes_example[112947,]
```

    ##           Number       Start.date
    ## 112947 138467142 2024-04-10 16:56
    ##        Start.station.number    Start.station
    ## 112947               200011 Furze Green, Bow
    ##                End.date End.station.number
    ## 112947 2024-04-10 17:14               1056
    ##                       End.station Bike.number
    ## 112947 Finsbury Square , Moorgate       58755
    ##        Bike.model Total.duration
    ## 112947    CLASSIC        18m 26s
    ##        Total.duration..ms.
    ## 112947             1106040

To avoid crashing this document, I have parsed the data elsewhere. In a
separate R file I collected the different files together, removing
irrelevant columns, and filtering for all journeys from Furze Green, the
nearest docking station to me. I then take the total sum of milliseconds
of journeys for each day of the year and then convert this to minutes.
See appendix A for the code.

The data covers 12th September 2022 to 31st December 2024. Earlier data
is available but before 12th September 2022, the data is formatted
sufficiently differently that the parsing would take too
long.<sup>E2</sup>

The data is freely to available to download from
[TFL](https://cycling.data.tfl.gov.uk/).

### A first look

Let us read in and plot the data

``` r
furze = read_csv("data/Furze.csv")
furze.df = data.frame(
  ds=strptime(furze$...1, format = "%Y-%m-%d"), 
  y=furze$x)
plot(furze.df)
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-24-1.png)<!-- -->

We have some notable outliers above the majority of the data. These are
easily removed. Looking into the relevant files, we see that the problem
dates feature some journeys of 30 days or more. We could assume these to
be thefts or system errors.<sup>E3</sup>

``` r
furze.df = furze.df[furze.df$y < 3000,]
plot(furze.df, type = "l",
     xlab = "Date", ylab = "Total minutes",
     main = "Total minutes rode on Santander bikes from Furze Green")
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-25-1.png)<!-- -->

Or better seen with some smoothing.

``` r
plot(furze.df$ds, stats::filter(furze.df$y, rep(1/14,14)),
     type = "l",
     xlab = "Date", ylab = "",
     main = "Filtered across a fortnight")
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-26-1.png)<!-- -->

It would be delightful to compare this to a dataset of daily max
temperature in London, but sadly there is not time to do this for this
project.<sup>E4</sup>

``` r
#plot(decompose(furze), cex.lab = 0.55)
```

## Trends with Prophet

Let us now pass the data to the Prophet tool and create a prediction for
the next year.

``` r
prophet_process = function(model){
    myfuture = make_future_dataframe(model,
                                     365,
                                     freq = "day")
    mypredict = predict(model, myfuture)
    prophet_plot_components(model, mypredict)
    plot(model,mypredict)
}
```

``` r
prophet_process(prophet(furze.df))
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-29-1.png)<!-- -->![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-29-2.png)<!-- -->

There is much to glean from this.

There is a clear preference among users for Thursdays, and an overall
increase in usage into the summer months, then sharply declining after.
The same plot also indicates another unexplained cycle; note the bumps
which are roughly monthly: could this be our weather variable? Or
perhaps as payday approaches each month, people become less keen to pay
for the tube.

And finally, an overall trend is identified of a general increase in
usage towards the start of 2024, and then a gradual decline since. I
couldn’t find evidence to corroborate this, but I do remember a change
to the pricing system occurring around this time or bit earlier (the
change made journeys under 30 minutes more expensive). If I’m right, TFL
really ought to reverse that decision! More likely though, this could be
due to competition with other services such as Lime or
Forest.<sup>E5</sup>

### Comparison to Finsbury Square

The advantage to this dataset is that I can easily look into processing
another set of very similar data. I have created another dataset with
the only change being the choice of stating station to the
aforementioned Finsbury Square. Naturally, the most prescient difference
in the raw data will be time of day, with these bikes all used around
5:30 when office workers go home. But my parsing removed this level of
precision.<sup>E6</sup> But what insight will we get from Prophet?

``` r
finsbury = read.csv("data/Finsbury.csv")
finsbury.df = data.frame(
  ds=strptime(finsbury[,1], format = "%Y-%m-%d"), 
  y=finsbury[,2])
plot(finsbury.df)
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-30-1.png)<!-- -->

Let us be fair and apply the same outlier criterion as before.

``` r
finsbury.df = finsbury.df[finsbury.df$y < 3000,]
plot(finsbury.df, type = "l",
     xlab = "Date", ylab = "Total minutes",
     main = "Total minutes rode on Santander bikes
     from Finsbury Square")
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-31-1.png)<!-- -->

Smooth in the same way as above and add Furze data in red.

``` r
plot(finsbury.df$ds, stats::filter(finsbury.df$y, rep(1/14,14)),
     type = "l",
     xlab = "Date", ylab = "",
     ylim = c(100,800))
lines(x = furze.df$ds,
      y = stats::filter(furze.df$y, rep(1/14,14)),
      col = "tomato")
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-32-1.png)<!-- -->

``` r
prophet_process(prophet(finsbury.df))
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-33-1.png)<!-- -->![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-33-2.png)<!-- -->

Here we have a clear preference for the weekdays, and while the summer
months do see an increase, the difference is less pronounced than at
Furze Green; likely as making a homeward journey in the rain is less
inconvenient than arriving at work soaked.

Also note the slimmer confidence intervals; the behaviour at this
station is much easier to predict than at Furze Green

The most striking difference is the change in overall trend with TFL
seeing a linear increase in usage at this station since 2023.

## Predictions

As learned above with the `co2` data, the proof is in the predictions.
Let us create datasets of the most recently available data (January
2025) and see if either model hold water.

``` r
par(mfrow = c(1,2))
furze_jan = read.csv("data/Furze_jan.csv")
furze_jan.df = data.frame(
  ds=strptime(furze_jan[,1], format = "%Y-%m-%d"), 
  y=furze_jan[,2])

furze_jan.df = furze_jan.df[furze_jan.df$y < 3000,]
plot(furze_jan.df[79:109,], type = "l",
     xlab = "Date", ylab = "Total minutes",
     main = "Furze Green")

finsbury_jan = read.csv("data/Finsbury_jan.csv")
finsbury_jan.df = data.frame(
  ds=strptime(finsbury_jan[,1], format = "%Y-%m-%d"), 
  y=finsbury_jan[,2])

finsbury_jan.df = finsbury_jan.df[finsbury_jan.df$y < 3000,]
plot(finsbury_jan.df[79:109,], type = "l",
     xlab = "Date", ylab = "Total minutes",
     main = "Finsbury Square")
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-34-1.png)<!-- -->

We can run prophet again and predict only the next month.

``` r
## For ease of reading plotting code below, I use single letter variable names.
## Refer to the earlier use of Prophet for actual understanding of this code chunk.

m = prophet(furze.df)
f = make_future_dataframe(m,
            31,
            freq = "day")
p = predict(m,f)
```

We can then extract the predicted values and indicate the confidence
interval in blue. Then the actual data is overlaid in red.

``` r
plot(p$ds[770:868], p$yhat[770:868], type = "l", ylim = c(-2000,3000),
     xlab = "Date", ylab = "Minutes",
     main = "Furze Green Predictions")
lines(p$ds[770:868], p$yhat_upper[770:868],
      type = "l", col = "blue")
lines(p$ds[770:868], p$yhat_lower[770:868],
      type = "l", col = "blue")
lines(furze_jan.df, col = "tomato")
lines(x = c(p$ds[841], p$ds[841]),
      y = c(-3000,3000),
      lty = 2)
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-36-1.png)<!-- -->

Not bad. I think it’s clear that Furze Green is not all that
interesting, as its total minutes can have spikes such as the one shown
here on 24th January and the variability this causes makes our
predictions not very robust.

Now for Finsbury Square:

``` r
m2 = prophet(finsbury.df)
f2 = make_future_dataframe(m2,
            31,
            freq = "day")
p2 = predict(m2,f2)
```

``` r
plot(p2$ds[770:868], p2$yhat[770:868], type = "l", ylim = c(-200,1000),
     xlab = "Date", ylab = "Minutes",
     main = "Finsbury Square Predictions")
lines(p2$ds[770:868], p2$yhat_upper[770:868],
      type = "l", col = "blue")
lines(p2$ds[770:868], p2$yhat_lower[770:868],
      type = "l", col = "blue")
lines(finsbury_jan.df, col = "tomato")
lines(x = c(p2$ds[838], p2$ds[838]),
      y = c(-3000,3000),
      lty = 2)
```

![](Coursework1_210033427_files/figure-gfm/unnamed-chunk-38-1.png)<!-- -->

The real values for January sit snugly within the prediction interval!

The caveat to this is that Prophet uses a default confidence level of
0.8 and we might prefer this a bit higher with a wider interval.

In any case, Prophet has certainly redeemed itself as a prediction tool
and is certainly something I will consider using in the future.

# Appendices

## Appendix A - data-loading code

The following is the code I used to load in and parse the data for Furze
Green, after placing the files in the ‘Bikes’ folder in ‘data’. I have
removed these files for ease of transfer but they could be easily
downloaded again [here](https://cycling.data.tfl.gov.uk/).

``` r
##Iterate over files in directory and only read relevant columns

#library(readr)
#library(dplyr)
#library(zoo)

#files = list.files(path = "data/Future", pattern = "\\.csv$", full.names = TRUE)
#files
#data = list()
#for (file in files){
#    a = read_csv(file, col_types = cols_only(
#        "Start date" = col_character(),
#        "Start station" = col_character(),
#        "Total duration (ms)" = col_double()))
#    data[[file]] = a
#}



##Bind the data together
#combined_data = bind_rows(data)

#Station = "Furze Green, Bow"

##Filter for station
#rowsofinterest = combined_data$`Start station` == Station
#collected_data = combined_data[rowsofinterest,]

##Extract times (and deal with the different formatting around summertime!)
#b1 = strptime(collected_data$`Start date`, format = "%Y-%m-%d %H:%M")
#b1 = b1[!is.na(b1)]
#b2 = strptime(collected_data$`Start date`, format = "%d/%m/%Y %H:%M")
#b2 = b2[!is.na(b2)]
#b = c(b1,b2)
#c =format(b, format = "%d/%m/%Y")
#collected_data["Date"] = c

##Create the time series
#x = data.frame(
#    ds = as.Date(unique(collected_data$Date),
#                 format = "%d/%m/%Y"))
#sort(x$ds)

#for (i in 1:length(x$ds)){
#    date = x$ds[i]
#    rowsofinterest2 = as.Date(collected_data$Date,
#                              format = "%d/%m/%Y") == date

#    x[i,"Minutes"] = sum(collected_data$`Total duration (ms)`[rowsofinterest2]*(1/1000)*(1/60),
#                    na.rm = TRUE)
#}

#y = read.zoo(x)
#plot(y)
#write.csv(y, file = "data/Furze_jan.csv")
```

## Appendix B - options for further study

### Questions I welcome answers to:

1.  Why does the uncertainty level decrease once I remove the yearly
    trend? I would have thought this wouldn’t make a difference
2.  How does one allow Prophet to predict a trend more complex than
    linear or logistic?

### Matters for further exploration:

1.  Confirm for certain the homoscedasticity of the `co2` data, and if
    not possible, do work to explain it
2.  Parse the bikes data further back in time, dealing with TFL’s
    inexplicable change of format in September 2022
3.  Experiment with filtering thresholds or choice of statistic. Should
    journeys over 3 hours count? Would looking at median journey time or
    total number of journeys be more interesting?
4.  Find weather data and compare to bike usage
5.  Perform similar analysis on the usage levels of other services like
    Forest or Lime.
6.  Parse the data and plot a time series which includes the precision
    of time of day. Then use the same methods to extract a daily trend.
